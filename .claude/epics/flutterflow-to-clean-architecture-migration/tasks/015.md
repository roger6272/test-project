---
epic: flutterflow-to-clean-architecture-migration
status: backlog
priority: P0
estimate: 7-8 hours
depends_on: [014]
week: 3-4
---

# Task 015: Implement Bluetooth Data Layer (ESP32 BLE Service)

## Description

Create the data layer for Bluetooth feature including ESP32 BLE service using flutter_blue_plus, models, and repository implementation. This handles the complex ESP32 protocol with chunking, JSON messages, and characteristic reads/writes.

## Acceptance Criteria

- [ ] BluetoothDeviceModel created
- [ ] ESP32BluetoothService created with flutter_blue_plus
- [ ] Chunking logic implemented (180-byte MTU, 30ms delay)
- [ ] JSON message protocol implemented (items, prefs, event types)
- [ ] BluetoothRepositoryImpl created
- [ ] All BLE characteristics properly configured
- [ ] Connection timeout and retry logic implemented
- [ ] Error handling for BLE failures

## Technical Details

**BluetoothDeviceModel** (data/models/bluetooth_device_model.dart):
```dart
import 'package:flutter_blue_plus/flutter_blue_plus.dart';
import '../../domain/entities/bluetooth_device.dart';

class BluetoothDeviceModel extends BluetoothDevice {
  final ScanResult scanResult;

  const BluetoothDeviceModel({
    required String id,
    required String name,
    required int rssi,
    required this.scanResult,
  }) : super(id: id, name: name, rssi: rssi);

  factory BluetoothDeviceModel.fromScanResult(ScanResult result) {
    return BluetoothDeviceModel(
      id: result.device.remoteId.toString(),
      name: result.device.platformName.isNotEmpty
          ? result.device.platformName
          : 'Unknown Device',
      rssi: result.rssi,
      scanResult: result,
    );
  }
}
```

**ESP32BluetoothService** (data/datasources/esp32_bluetooth_service.dart):
```dart
import 'dart:async';
import 'dart:convert';
import 'package:flutter_blue_plus/flutter_blue_plus.dart';
import '../../../../core/error/exceptions.dart';
import '../../../../core/utils/bluetooth_constants.dart';
import '../../../items/domain/entities/item.dart';

abstract class ESP32BluetoothService {
  Stream<List<ScanResult>> scanForDevices();
  Future<void> connectToDevice(String deviceId);
  Future<void> disconnect();
  Stream<BluetoothConnectionState> watchConnectionState(String deviceId);
  Future<void> sendItemList(List<Item> items);
  Future<void> sendTimezone(int offsetMinutes);
  Stream<Map<String, dynamic>> listenForEvents();
}

class ESP32BluetoothServiceImpl implements ESP32BluetoothService {
  BluetoothDevice? _connectedDevice;
  BluetoothCharacteristic? _setItemsCharacteristic;
  BluetoothCharacteristic? _writeCharacteristic;
  BluetoothCharacteristic? _notifyCharacteristic;

  @override
  Stream<List<ScanResult>> scanForDevices() async* {
    try {
      // Check Bluetooth adapter
      if (!await FlutterBluePlus.isSupported) {
        throw BluetoothException('Bluetooth not supported on this device');
      }

      // Start scan
      await FlutterBluePlus.startScan(
        timeout: Duration(seconds: BluetoothConstants.scanTimeoutSeconds),
        withServices: [Guid(BluetoothConstants.serviceUUID)],
      );

      yield* FlutterBluePlus.scanResults;
    } catch (e) {
      throw BluetoothException('Scan failed: ${e.toString()}');
    }
  }

  @override
  Future<void> connectToDevice(String deviceId) async {
    try {
      // Find device
      final devices = FlutterBluePlus.connectedDevices;
      BluetoothDevice? device = devices.firstWhere(
        (d) => d.remoteId.toString() == deviceId,
        orElse: () => throw BluetoothException('Device not found'),
      );

      // Connect
      await device.connect(
        timeout: Duration(seconds: BluetoothConstants.connectionTimeoutSeconds),
      );

      _connectedDevice = device;

      // Discover services
      final services = await device.discoverServices();

      // Find service
      final service = services.firstWhere(
        (s) => s.uuid.toString() == BluetoothConstants.serviceUUID,
        orElse: () => throw BluetoothException('Service not found'),
      );

      // Find characteristics
      for (var char in service.characteristics) {
        if (char.uuid.toString() == BluetoothConstants.setItemsCharacteristicUUID) {
          _setItemsCharacteristic = char;
        } else if (char.uuid.toString() == BluetoothConstants.writeCharacteristicUUID) {
          _writeCharacteristic = char;
        } else if (char.uuid.toString() == BluetoothConstants.notifyCharacteristicUUID) {
          _notifyCharacteristic = char;
          // Enable notifications
          await char.setNotifyValue(true);
        }
      }

      if (_setItemsCharacteristic == null || _writeCharacteristic == null) {
        throw BluetoothException('Required characteristics not found');
      }
    } catch (e) {
      throw BluetoothException('Connection failed: ${e.toString()}');
    }
  }

  @override
  Future<void> disconnect() async {
    try {
      if (_connectedDevice != null) {
        await _connectedDevice!.disconnect();
        _connectedDevice = null;
        _setItemsCharacteristic = null;
        _writeCharacteristic = null;
        _notifyCharacteristic = null;
      }
    } catch (e) {
      throw BluetoothException('Disconnect failed: ${e.toString()}');
    }
  }

  @override
  Stream<BluetoothConnectionState> watchConnectionState(String deviceId) {
    if (_connectedDevice == null) {
      return Stream.value(BluetoothConnectionState.disconnected);
    }
    return _connectedDevice!.connectionState;
  }

  @override
  Future<void> sendItemList(List<Item> items) async {
    if (_setItemsCharacteristic == null) {
      throw BluetoothException('Not connected to device');
    }

    try {
      // Build JSON message
      final itemsJson = {
        'type': 'items',
        'items': items.map((item) => {
          'id': item.id,
          'name': item.name,
          'count': item.count,
          'increment_by': item.incrementBy,
          'reminder': _reminderToString(item.reminder),
          'reminder_value': item.reminderValue,
        }).toList(),
      };

      final jsonString = jsonEncode(itemsJson);

      // Chunk and send
      await _sendChunked(jsonString, _setItemsCharacteristic!);
    } catch (e) {
      throw BluetoothException('Failed to send items: ${e.toString()}');
    }
  }

  @override
  Future<void> sendTimezone(int offsetMinutes) async {
    if (_writeCharacteristic == null) {
      throw BluetoothException('Not connected to device');
    }

    try {
      final prefsJson = {
        'type': 'prefs',
        'timezone_offset': offsetMinutes,
      };

      final jsonString = jsonEncode(prefsJson);

      await _sendChunked(jsonString, _writeCharacteristic!);
    } catch (e) {
      throw BluetoothException('Failed to send timezone: ${e.toString()}');
    }
  }

  @override
  Stream<Map<String, dynamic>> listenForEvents() async* {
    if (_notifyCharacteristic == null) {
      throw BluetoothException('Not connected to device');
    }

    await for (final value in _notifyCharacteristic!.lastValueStream) {
      try {
        final message = utf8.decode(value);
        final json = jsonDecode(message) as Map<String, dynamic>;
        yield json;
      } catch (e) {
        // Ignore malformed messages
        continue;
      }
    }
  }

  // Helper: Chunk message into 180-byte packets
  Future<void> _sendChunked(
    String message,
    BluetoothCharacteristic characteristic,
  ) async {
    final bytes = utf8.encode(message);
    final chunkSize = BluetoothConstants.mtuLimit;

    for (var i = 0; i < bytes.length; i += chunkSize) {
      final end = (i + chunkSize < bytes.length) ? i + chunkSize : bytes.length;
      final chunk = bytes.sublist(i, end);

      await characteristic.write(chunk, withoutResponse: false);

      // Delay between chunks
      if (end < bytes.length) {
        await Future.delayed(
          Duration(milliseconds: BluetoothConstants.chunkDelayMs),
        );
      }
    }

    // Send newline delimiter
    await characteristic.write([10], withoutResponse: false);
  }

  String _reminderToString(ReminderType reminder) {
    switch (reminder) {
      case ReminderType.target:
        return 'TARGET';
      case ReminderType.interval:
        return 'INTERVAL';
      case ReminderType.everyTime:
        return 'EVERY_TIME';
      default:
        return 'NONE';
    }
  }
}
```

**BluetoothRepositoryImpl** (data/repositories/bluetooth_repository_impl.dart):
```dart
import 'package:dartz/dartz.dart';
import 'package:flutter_blue_plus/flutter_blue_plus.dart' as fbp;
import '../../../../core/error/exceptions.dart';
import '../../../../core/error/failures.dart';
import '../../../items/domain/entities/item.dart';
import '../../domain/entities/bluetooth_device.dart';
import '../../domain/entities/connection_state.dart';
import '../../domain/repositories/bluetooth_repository.dart';
import '../datasources/esp32_bluetooth_service.dart';
import '../models/bluetooth_device_model.dart';

class BluetoothRepositoryImpl implements BluetoothRepository {
  final ESP32BluetoothService service;

  BluetoothRepositoryImpl(this.service);

  @override
  Stream<Either<Failure, List<BluetoothDevice>>> scanDevices() async* {
    try {
      await for (final results in service.scanForDevices()) {
        final devices = results
            .map((r) => BluetoothDeviceModel.fromScanResult(r))
            .toList();
        yield Right(devices);
      }
    } on BluetoothException catch (e) {
      yield Left(BluetoothFailure(e.message));
    }
  }

  @override
  Future<Either<Failure, void>> connectDevice(String deviceId) async {
    try {
      await service.connectToDevice(deviceId);
      return const Right(null);
    } on BluetoothException catch (e) {
      return Left(BluetoothFailure(e.message));
    }
  }

  @override
  Future<Either<Failure, void>> disconnectDevice() async {
    try {
      await service.disconnect();
      return const Right(null);
    } on BluetoothException catch (e) {
      return Left(BluetoothFailure(e.message));
    }
  }

  @override
  Future<Either<Failure, void>> sendItemList(List<Item> items) async {
    try {
      await service.sendItemList(items);
      return const Right(null);
    } on BluetoothException catch (e) {
      return Left(BluetoothFailure(e.message));
    }
  }

  @override
  Future<Either<Failure, void>> sendTimezone(int offsetMinutes) async {
    try {
      await service.sendTimezone(offsetMinutes);
      return const Right(null);
    } on BluetoothException catch (e) {
      return Left(BluetoothFailure(e.message));
    }
  }

  @override
  Stream<ConnectionState> watchConnectionState() async* {
    // Implementation depends on service
    yield const ConnectionState.disconnected();
  }

  @override
  Stream<Map<String, dynamic>> listenForEvents() {
    return service.listenForEvents();
  }
}
```

## Dependencies

- Task 014: Bluetooth domain layer
- flutter_blue_plus package

## Testing

Test with mocked flutter_blue_plus:
- Test scanning returns devices
- Test connection succeeds/fails
- Test chunking logic (180-byte MTU)
- Test JSON message formatting
- Test characteristic discovery

## Notes

- ESP32 requires 30ms delay between chunks
- Messages end with newline delimiter
- Characteristics must be discovered after connection
- Handle BLE permissions on Android/iOS
- Test with real ESP32 in Task 020

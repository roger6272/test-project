---
epic: flutterflow-to-clean-architecture-migration
status: backlog
priority: P0
estimate: 5-6 hours
depends_on: [007]
week: 2
---

# Task 008: Implement Items Data Layer

## Description

Create the data layer for Items feature including Firestore models, data sources, and repository implementation. This layer handles persistence and maps between domain entities and Firestore documents.

## Acceptance Criteria

- [ ] ItemModel created in `features/items/data/models/item_model.dart`
- [ ] ItemModel extends Item entity
- [ ] Firestore serialization implemented (toJson, fromJson, fromFirestore)
- [ ] ItemFirestoreDataSource created in `features/items/data/datasources/item_firestore_datasource.dart`
- [ ] ItemRepositoryImpl created in `features/items/data/repositories/item_repository_impl.dart`
- [ ] Repository converts between models and entities
- [ ] Error handling converts exceptions to failures
- [ ] All CRUD operations working with Firestore

## Technical Details

**ItemModel** (data/models/item_model.dart):
```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/entities/item.dart';

class ItemModel extends Item {
  const ItemModel({
    required String id,
    required String name,
    required int count,
    required int todayCount,
    required int incrementBy,
    required ReminderType reminder,
    required int reminderValue,
    required DateTime lastResetTime,
    required DateTime lastUpdated,
    required String userId,
  }) : super(
          id: id,
          name: name,
          count: count,
          todayCount: todayCount,
          incrementBy: incrementBy,
          reminder: reminder,
          reminderValue: reminderValue,
          lastResetTime: lastResetTime,
          lastUpdated: lastUpdated,
          userId: userId,
        );

  factory ItemModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return ItemModel(
      id: doc.id,
      name: data['item_name'] as String,
      count: data['count'] as int? ?? 0,
      todayCount: data['todaycount'] as int? ?? 0,
      incrementBy: data['increment_by'] as int? ?? 1,
      reminder: _reminderFromString(data['reminder'] as String?),
      reminderValue: data['reminder_value'] as int? ?? 0,
      lastResetTime: DateTime.fromMillisecondsSinceEpoch(
        data['lastResetTime'] as int? ?? 0,
      ),
      lastUpdated: DateTime.fromMillisecondsSinceEpoch(
        data['lastUpdated'] as int? ?? 0,
      ),
      userId: data['user_id'] as String,
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'item_name': name,
      'count': count,
      'todaycount': todayCount,
      'increment_by': incrementBy,
      'reminder': _reminderToString(reminder),
      'reminder_value': reminderValue,
      'lastResetTime': lastResetTime.millisecondsSinceEpoch,
      'lastUpdated': lastUpdated.millisecondsSinceEpoch,
      'user_id': userId,
    };
  }

  static ReminderType _reminderFromString(String? value) {
    switch (value) {
      case 'TARGET':
        return ReminderType.target;
      case 'INTERVAL':
        return ReminderType.interval;
      case 'EVERY_TIME':
        return ReminderType.everyTime;
      default:
        return ReminderType.none;
    }
  }

  static String _reminderToString(ReminderType reminder) {
    switch (reminder) {
      case ReminderType.target:
        return 'TARGET';
      case ReminderType.interval:
        return 'INTERVAL';
      case ReminderType.everyTime:
        return 'EVERY_TIME';
      default:
        return 'NONE';
    }
  }
}
```

**ItemFirestoreDataSource** (data/datasources/item_firestore_datasource.dart):
```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../../../core/error/exceptions.dart';
import '../models/item_model.dart';

abstract class ItemFirestoreDataSource {
  Future<List<ItemModel>> getItems(String userId);
  Future<void> createItem(ItemModel item);
  Future<void> updateItem(ItemModel item);
  Future<void> deleteItem(String id);
  Stream<List<ItemModel>> watchItems(String userId);
}

class ItemFirestoreDataSourceImpl implements ItemFirestoreDataSource {
  final FirebaseFirestore firestore;

  ItemFirestoreDataSourceImpl(this.firestore);

  @override
  Future<List<ItemModel>> getItems(String userId) async {
    try {
      final snapshot = await firestore
          .collection('Item')
          .where('user_id', isEqualTo: userId)
          .get();

      return snapshot.docs.map((doc) => ItemModel.fromFirestore(doc)).toList();
    } catch (e) {
      throw ServerException('Failed to fetch items: ${e.toString()}');
    }
  }

  @override
  Future<void> createItem(ItemModel item) async {
    try {
      await firestore.collection('Item').doc(item.id).set(item.toFirestore());
    } catch (e) {
      throw ServerException('Failed to create item: ${e.toString()}');
    }
  }

  @override
  Future<void> updateItem(ItemModel item) async {
    try {
      await firestore.collection('Item').doc(item.id).update(item.toFirestore());
    } catch (e) {
      throw ServerException('Failed to update item: ${e.toString()}');
    }
  }

  @override
  Future<void> deleteItem(String id) async {
    try {
      await firestore.collection('Item').doc(id).delete();
    } catch (e) {
      throw ServerException('Failed to delete item: ${e.toString()}');
    }
  }

  @override
  Stream<List<ItemModel>> watchItems(String userId) {
    return firestore
        .collection('Item')
        .where('user_id', isEqualTo: userId)
        .snapshots()
        .map((snapshot) =>
            snapshot.docs.map((doc) => ItemModel.fromFirestore(doc)).toList());
  }
}
```

**ItemRepositoryImpl** (data/repositories/item_repository_impl.dart):
```dart
import 'package:dartz/dartz.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../../../core/error/exceptions.dart';
import '../../../../core/error/failures.dart';
import '../../domain/entities/item.dart';
import '../../domain/repositories/item_repository.dart';
import '../datasources/item_firestore_datasource.dart';
import '../models/item_model.dart';

class ItemRepositoryImpl implements ItemRepository {
  final ItemFirestoreDataSource dataSource;
  final FirebaseAuth auth;

  ItemRepositoryImpl(this.dataSource, this.auth);

  String get _userId => auth.currentUser?.uid ?? '';

  @override
  Future<Either<Failure, List<Item>>> getItems() async {
    try {
      final items = await dataSource.getItems(_userId);
      return Right(items);
    } on ServerException catch (e) {
      return Left(ServerFailure(e.message));
    }
  }

  @override
  Future<Either<Failure, void>> createItem(Item item) async {
    try {
      final model = _itemToModel(item);
      await dataSource.createItem(model);
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(e.message));
    }
  }

  @override
  Future<Either<Failure, void>> updateItem(Item item) async {
    try {
      final model = _itemToModel(item);
      await dataSource.updateItem(model);
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(e.message));
    }
  }

  @override
  Future<Either<Failure, void>> deleteItem(String id) async {
    try {
      await dataSource.deleteItem(id);
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(e.message));
    }
  }

  @override
  Future<Either<Failure, void>> activateItem(String id) async {
    // TODO: Implement activation toggle logic
    return const Right(null);
  }

  @override
  Stream<List<Item>> watchItems() {
    return dataSource.watchItems(_userId).map((models) => models);
  }

  ItemModel _itemToModel(Item item) {
    return ItemModel(
      id: item.id,
      name: item.name,
      count: item.count,
      todayCount: item.todayCount,
      incrementBy: item.incrementBy,
      reminder: item.reminder,
      reminderValue: item.reminderValue,
      lastResetTime: item.lastResetTime,
      lastUpdated: item.lastUpdated,
      userId: item.userId,
    );
  }
}
```

## Dependencies

- Task 007: Items domain layer must be complete
- FirebaseFirestore and FirebaseAuth configured

## Testing

Write tests in `test/features/items/data/`:

**Model Tests** (models/item_model_test.dart):
```dart
void main() {
  final testItemModel = ItemModel(
    id: 'test_123',
    name: 'Coffee',
    count: 10,
    todayCount: 5,
    incrementBy: 1,
    reminder: ReminderType.target,
    reminderValue: 20,
    lastResetTime: DateTime(2026, 1, 1),
    lastUpdated: DateTime(2026, 1, 2),
    userId: 'user_123',
  );

  group('ItemModel', () {
    test('should be a subclass of Item entity', () {
      expect(testItemModel, isA<Item>());
    });

    test('toFirestore should return valid map', () {
      final result = testItemModel.toFirestore();

      expect(result['item_name'], 'Coffee');
      expect(result['count'], 10);
      expect(result['reminder'], 'TARGET');
    });

    test('fromFirestore should create model from DocumentSnapshot', () {
      // Test with mock DocumentSnapshot
    });
  });
}
```

**DataSource Tests** (datasources/item_firestore_datasource_test.dart):
- Test getItems with mock Firestore
- Test createItem success and failure
- Test updateItem, deleteItem
- Test watchItems stream

**Repository Tests** (repositories/item_repository_impl_test.dart):
- Test all methods return Either<Failure, T>
- Test exception to failure conversion
- Verify data source calls
- Test with mocked FirebaseAuth for userId

## Notes

- ItemModel extends Item entity to ensure type compatibility
- Repository gets userId from FirebaseAuth.currentUser
- All Firestore operations wrapped in try-catch for exception handling
- Stream methods enable real-time UI updates
- Firestore field names match existing schema ('item_name', 'todaycount', etc.)

---
epic: flutterflow-to-clean-architecture-migration
status: backlog
priority: P1
estimate: 5-6 hours
depends_on: [022]
week: 5
---

# Task 023: Implement Charts BLoC and Aggregation Logic

## Description

Create Charts BLoC with aggregation logic to generate bar charts and cumulative charts from event data. Implement efficient data aggregation for daily, weekly, and monthly views.

## Acceptance Criteria

- [ ] GetChartDataUseCase created with aggregation logic
- [ ] GetCumulativeChartDataUseCase created
- [ ] ChartsEvent classes created (LoadBarChart, LoadCumulativeChart, ChangeDateRange)
- [ ] ChartsState classes created (ChartsLoading, ChartsLoaded, ChartsError)
- [ ] ChartsBloc created
- [ ] Aggregation logic supports daily, weekly, monthly
- [ ] Cumulative calculations implemented

## Technical Details

**Chart Data Models**:
```dart
class ChartDataPoint extends Equatable {
  final DateTime date;
  final int value;

  const ChartDataPoint({required this.date, required this.value});

  @override
  List<Object?> get props => [date, value];
}

class ChartData extends Equatable {
  final List<ChartDataPoint> dataPoints;
  final String aggregationLevel; // 'daily', 'weekly', 'monthly'

  const ChartData({required this.dataPoints, required this.aggregationLevel});

  @override
  List<Object?> get props => [dataPoints, aggregationLevel];
}
```

**GetChartDataUseCase**:
```dart
class GetChartDataUseCase implements UseCase<ChartData, GetChartDataParams> {
  final EventLogRepository repository;

  GetChartDataUseCase(this.repository);

  @override
  Future<Either<Failure, ChartData>> call(GetChartDataParams params) async {
    final eventsResult = await repository.getEventsByDateRange(
      params.startDate,
      params.endDate,
    );

    return eventsResult.fold(
      (failure) => Left(failure),
      (events) {
        final aggregated = _aggregateEvents(
          events,
          params.aggregationLevel,
        );
        return Right(ChartData(
          dataPoints: aggregated,
          aggregationLevel: params.aggregationLevel,
        ));
      },
    );
  }

  List<ChartDataPoint> _aggregateEvents(
    List<EventLog> events,
    String aggregationLevel,
  ) {
    final Map<DateTime, int> aggregated = {};

    for (var event in events) {
      final key = _getAggregationKey(event.createdTime, aggregationLevel);
      aggregated[key] = (aggregated[key] ?? 0) + event.increment;
    }

    return aggregated.entries
        .map((e) => ChartDataPoint(date: e.key, value: e.value))
        .toList()
      ..sort((a, b) => a.date.compareTo(b.date));
  }

  DateTime _getAggregationKey(DateTime date, String level) {
    switch (level) {
      case 'daily':
        return DateTime(date.year, date.month, date.day);
      case 'weekly':
        // Start of week (Monday)
        final weekday = date.weekday;
        return DateTime(date.year, date.month, date.day - (weekday - 1));
      case 'monthly':
        return DateTime(date.year, date.month);
      default:
        return DateTime(date.year, date.month, date.day);
    }
  }
}
```

**GetCumulativeChartDataUseCase**:
```dart
class GetCumulativeChartDataUseCase implements UseCase<ChartData, GetChartDataParams> {
  final EventLogRepository repository;

  GetCumulativeChartDataUseCase(this.repository);

  @override
  Future<Either<Failure, ChartData>> call(GetChartDataParams params) async {
    final eventsResult = await repository.getEventsByDateRange(
      params.startDate,
      params.endDate,
    );

    return eventsResult.fold(
      (failure) => Left(failure),
      (events) {
        final aggregated = _calculateCumulative(events);
        return Right(ChartData(
          dataPoints: aggregated,
          aggregationLevel: 'daily',
        ));
      },
    );
  }

  List<ChartDataPoint> _calculateCumulative(List<EventLog> events) {
    // Sort events by date
    final sorted = events..sort((a, b) => a.createdTime.compareTo(b.createdTime));

    final Map<DateTime, int> cumulative = {};
    var total = 0;

    for (var event in sorted) {
      final date = DateTime(
        event.createdTime.year,
        event.createdTime.month,
        event.createdTime.day,
      );
      total += event.increment;
      cumulative[date] = total;
    }

    return cumulative.entries
        .map((e) => ChartDataPoint(date: e.key, value: e.value))
        .toList()
      ..sort((a, b) => a.date.compareTo(b.date));
  }
}
```

**ChartsBloc**:
```dart
class ChartsBloc extends Bloc<ChartsEvent, ChartsState> {
  final GetChartDataUseCase getChartData;
  final GetCumulativeChartDataUseCase getCumulativeChartData;

  ChartsBloc({
    required this.getChartData,
    required this.getCumulativeChartData,
  }) : super(ChartsInitial()) {
    on<LoadBarChart>(_onLoadBarChart);
    on<LoadCumulativeChart>(_onLoadCumulativeChart);
    on<ChangeDateRange>(_onChangeDateRange);
  }

  Future<void> _onLoadBarChart(LoadBarChart event, Emitter<ChartsState> emit) async {
    emit(ChartsLoading());

    final result = await getChartData(GetChartDataParams(
      startDate: event.startDate,
      endDate: event.endDate,
      aggregationLevel: event.aggregationLevel,
    ));

    result.fold(
      (failure) => emit(ChartsError(failure.message)),
      (chartData) => emit(ChartsLoaded(chartData)),
    );
  }
}
```

## Dependencies

- Task 022: EventsBloc
- Task 021: EventLog data layer

## Testing

Unit tests:
- Test daily aggregation
- Test weekly aggregation (Monday start)
- Test monthly aggregation
- Test cumulative calculations
- Test edge cases (no data, single day, etc.)

## Notes

- Aggregation runs in use case layer (business logic)
- Weekly aggregation starts on Monday
- Cumulative chart shows running total
- Charts update when new events arrive

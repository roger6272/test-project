---
epic: flutterflow-to-clean-architecture-migration
status: backlog
priority: P1
estimate: 3-4 hours
depends_on: [010]
week: 3
---

# Task 012: Write Widget Tests for Items UI

## Description

Create widget tests for Items UI components to ensure proper rendering, user interactions, and state management integration. Achieve 50%+ test coverage for Items presentation layer.

## Acceptance Criteria

- [ ] ItemsPage widget tests written
- [ ] ItemSetupPage widget tests written
- [ ] ItemUpdatePage widget tests written
- [ ] ItemListTile widget tests written
- [ ] Form validation tested
- [ ] Navigation flows tested
- [ ] BLoC integration tested
- [ ] Widget test coverage ≥ 50%

## Technical Details

**ItemsPage Tests** (test/features/items/presentation/pages/items_page_test.dart):

```dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:mocktail/mocktail.dart';

class MockItemsBloc extends MockBloc<ItemsEvent, ItemsState> implements ItemsBloc {}

void main() {
  late MockItemsBloc mockBloc;

  setUp(() {
    mockBloc = MockItemsBloc();
  });

  Widget makeTestableWidget(Widget child) {
    return MaterialApp(
      home: BlocProvider<ItemsBloc>.value(
        value: mockBloc,
        child: child,
      ),
    );
  }

  group('ItemsPage', () {
    testWidgets('displays loading indicator when state is ItemsLoading',
        (tester) async {
      // arrange
      when(() => mockBloc.state).thenReturn(ItemsLoading());

      // act
      await tester.pumpWidget(makeTestableWidget(const ItemsPage()));

      // assert
      expect(find.byType(CircularProgressIndicator), findsOneWidget);
    });

    testWidgets('displays items list when state is ItemsLoaded',
        (tester) async {
      // arrange
      final testItems = [testItem];
      when(() => mockBloc.state).thenReturn(ItemsLoaded(testItems));

      // act
      await tester.pumpWidget(makeTestableWidget(const ItemsPage()));

      // assert
      expect(find.byType(ItemListTile), findsOneWidget);
      expect(find.text('Coffee'), findsOneWidget);
    });

    testWidgets('displays empty state when items list is empty',
        (tester) async {
      // arrange
      when(() => mockBloc.state).thenReturn(const ItemsLoaded([]));

      // act
      await tester.pumpWidget(makeTestableWidget(const ItemsPage()));

      // assert
      expect(find.text('No items yet'), findsOneWidget);
      expect(find.text('Tap + to create your first item'), findsOneWidget);
    });

    testWidgets('displays error message when state is ItemsError',
        (tester) async {
      // arrange
      when(() => mockBloc.state).thenReturn(ItemsLoading());
      whenListen(
        mockBloc,
        Stream.fromIterable([
          const ItemsError('Failed to load items'),
        ]),
        initialState: ItemsLoading(),
      );

      // act
      await tester.pumpWidget(makeTestableWidget(const ItemsPage()));
      await tester.pump();

      // assert
      expect(find.text('Failed to load items'), findsOneWidget);
    });

    testWidgets('toggles count view when icon button tapped',
        (tester) async {
      // arrange
      when(() => mockBloc.state).thenReturn(
        ItemsLoaded([testItem], showTodayCount: false),
      );
      when(() => mockBloc.add(any())).thenReturn(null);

      // act
      await tester.pumpWidget(makeTestableWidget(const ItemsPage()));
      await tester.tap(find.byIcon(Icons.calendar_month));

      // assert
      verify(() => mockBloc.add(const ToggleCountView(true))).called(1);
    });

    testWidgets('FloatingActionButton navigates to item setup',
        (tester) async {
      // arrange
      when(() => mockBloc.state).thenReturn(const ItemsLoaded([]));

      // act
      await tester.pumpWidget(makeTestableWidget(const ItemsPage()));
      await tester.tap(find.byType(FloatingActionButton));
      await tester.pumpAndSettle();

      // assert - verify navigation would occur
      // (actual navigation testing requires GoRouter setup)
    });
  });
}
```

**ItemSetupPage Tests** (test/features/items/presentation/pages/item_setup_page_test.dart):

```dart
void main() {
  late MockItemsBloc mockBloc;

  setUp(() {
    mockBloc = MockItemsBloc();
  });

  Widget makeTestableWidget() {
    return MaterialApp(
      home: BlocProvider<ItemsBloc>.value(
        value: mockBloc,
        child: const ItemSetupPage(),
      ),
    );
  }

  group('ItemSetupPage', () {
    testWidgets('displays all form fields', (tester) async {
      // arrange
      when(() => mockBloc.state).thenReturn(ItemsInitial());

      // act
      await tester.pumpWidget(makeTestableWidget());

      // assert
      expect(find.text('Item Name'), findsOneWidget);
      expect(find.text('Increment By'), findsOneWidget);
      expect(find.text('Reminder Type'), findsOneWidget);
      expect(find.text('Create Item'), findsOneWidget);
    });

    testWidgets('shows validation error for empty name', (tester) async {
      // arrange
      when(() => mockBloc.state).thenReturn(ItemsInitial());

      // act
      await tester.pumpWidget(makeTestableWidget());
      await tester.tap(find.text('Create Item'));
      await tester.pump();

      // assert
      expect(find.text('Item name is required'), findsOneWidget);
    });

    testWidgets('shows validation error for name > 30 chars', (tester) async {
      // arrange
      when(() => mockBloc.state).thenReturn(ItemsInitial());

      // act
      await tester.pumpWidget(makeTestableWidget());
      await tester.enterText(
        find.byType(TextFormField).first,
        'A' * 31,
      );
      await tester.tap(find.text('Create Item'));
      await tester.pump();

      // assert
      expect(
        find.text('Item name must be 30 characters or less'),
        findsOneWidget,
      );
    });

    testWidgets('creates item with valid input', (tester) async {
      // arrange
      when(() => mockBloc.state).thenReturn(ItemsInitial());
      when(() => mockBloc.add(any())).thenReturn(null);

      // act
      await tester.pumpWidget(makeTestableWidget());
      await tester.enterText(
        find.byType(TextFormField).first,
        'Coffee',
      );
      await tester.tap(find.text('Create Item'));
      await tester.pump();

      // assert
      verify(() => mockBloc.add(any<CreateItem>())).called(1);
    });

    testWidgets('shows reminder value field when reminder type selected',
        (tester) async {
      // arrange
      when(() => mockBloc.state).thenReturn(ItemsInitial());

      // act
      await tester.pumpWidget(makeTestableWidget());
      await tester.tap(find.text('None'));
      await tester.pumpAndSettle();
      await tester.tap(find.text('Target').last);
      await tester.pumpAndSettle();

      // assert
      expect(find.text('Reminder Value'), findsOneWidget);
    });
  });
}
```

**ItemListTile Tests** (test/features/items/presentation/widgets/item_list_tile_test.dart):

```dart
void main() {
  final testItem = Item(
    id: 'test_123',
    name: 'Coffee',
    count: 10,
    todayCount: 5,
    incrementBy: 1,
    reminder: ReminderType.target,
    reminderValue: 20,
    lastResetTime: DateTime(2026, 1, 1),
    lastUpdated: DateTime(2026, 1, 2),
    userId: 'user_123',
  );

  Widget makeTestableWidget({required bool showTodayCount}) {
    return MaterialApp(
      home: Scaffold(
        body: ItemListTile(
          item: testItem,
          showTodayCount: showTodayCount,
          onTap: () {},
          onEdit: () {},
          onDelete: () {},
        ),
      ),
    );
  }

  group('ItemListTile', () {
    testWidgets('displays item name', (tester) async {
      // act
      await tester.pumpWidget(makeTestableWidget(showTodayCount: false));

      // assert
      expect(find.text('Coffee'), findsOneWidget);
    });

    testWidgets('displays total count when showTodayCount is false',
        (tester) async {
      // act
      await tester.pumpWidget(makeTestableWidget(showTodayCount: false));

      // assert
      expect(find.text('10'), findsOneWidget);
    });

    testWidgets('displays today count when showTodayCount is true',
        (tester) async {
      // act
      await tester.pumpWidget(makeTestableWidget(showTodayCount: true));

      // assert
      expect(find.text('5'), findsOneWidget);
    });

    testWidgets('displays increment and reminder info', (tester) async {
      // act
      await tester.pumpWidget(makeTestableWidget(showTodayCount: false));

      // assert
      expect(find.text('Increment: 1 • Target: 20'), findsOneWidget);
    });

    testWidgets('calls onTap when tapped', (tester) async {
      // arrange
      var tapped = false;

      // act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ItemListTile(
              item: testItem,
              showTodayCount: false,
              onTap: () => tapped = true,
              onEdit: () {},
              onDelete: () {},
            ),
          ),
        ),
      );
      await tester.tap(find.byType(ListTile));

      // assert
      expect(tapped, true);
    });
  });
}
```

## Dependencies

- Task 010: Items UI pages must be implemented
- flutter_test package
- mocktail and bloc_test for mocking

## Testing

Run widget tests:

```bash
# Run all widget tests
flutter test test/features/items/presentation/

# Run specific test file
flutter test test/features/items/presentation/pages/items_page_test.dart

# Run with coverage
flutter test --coverage test/features/items/presentation/
```

Test checklist:
- [ ] All widgets render without errors
- [ ] Loading states display correctly
- [ ] Empty states display correctly
- [ ] Error states display correctly
- [ ] Forms validate input correctly
- [ ] User interactions trigger correct events
- [ ] Navigation flows work as expected

## Notes

- Use makeTestableWidget helper to wrap widgets with necessary providers
- Mock BLoCs with mocktail and bloc_test
- Use pump() and pumpAndSettle() appropriately
- Test user interactions (tap, enterText)
- Verify BLoC events are dispatched correctly
- Widget tests are faster than integration tests
- Focus on critical user paths

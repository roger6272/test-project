---
epic: flutterflow-to-clean-architecture-migration
status: backlog
priority: P0
estimate: 6-8 hours
depends_on: [009]
week: 2-3
---

# Task 010: Migrate Items UI Pages and Widgets

## Description

Migrate Items UI from FlutterFlow to clean architecture using BLoC pattern. This includes the items list page, item setup (create) page, item update page, and reusable widgets.

## Acceptance Criteria

- [ ] ItemsPage created in `features/items/presentation/pages/items_page.dart`
- [ ] ItemSetupPage created for item creation
- [ ] ItemUpdatePage created for item editing
- [ ] ItemListTile widget created for displaying items
- [ ] ItemSlidableActions widget created for swipe actions
- [ ] All pages use BlocProvider and BlocBuilder
- [ ] Navigation integrated with GoRouter
- [ ] UI matches FlutterFlow design
- [ ] Forms include validation

## Technical Details

**ItemsPage** (presentation/pages/items_page.dart):
```dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import '../../../../core/di/injection.dart';
import '../bloc/items_bloc.dart';
import '../widgets/item_list_tile.dart';

class ItemsPage extends StatelessWidget {
  const ItemsPage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (_) => sl<ItemsBloc>()..add(LoadItems()),
      child: Scaffold(
        appBar: AppBar(
          title: const Text('My Items'),
          actions: [
            BlocBuilder<ItemsBloc, ItemsState>(
              builder: (context, state) {
                if (state is ItemsLoaded) {
                  return IconButton(
                    icon: Icon(
                      state.showTodayCount ? Icons.today : Icons.calendar_month,
                    ),
                    onPressed: () {
                      context.read<ItemsBloc>().add(
                            ToggleCountView(!state.showTodayCount),
                          );
                    },
                  );
                }
                return const SizedBox.shrink();
              },
            ),
          ],
        ),
        body: BlocConsumer<ItemsBloc, ItemsState>(
          listener: (context, state) {
            if (state is ItemsError) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text(state.message)),
              );
            }
          },
          builder: (context, state) {
            if (state is ItemsLoading) {
              return const Center(child: CircularProgressIndicator());
            }

            if (state is ItemsLoaded) {
              if (state.items.isEmpty) {
                return Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.inbox, size: 64, color: Colors.grey),
                      const SizedBox(height: 16),
                      Text(
                        'No items yet',
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                      const SizedBox(height: 8),
                      Text(
                        'Tap + to create your first item',
                        style: Theme.of(context).textTheme.bodyMedium,
                      ),
                    ],
                  ),
                );
              }

              return ListView.builder(
                itemCount: state.items.length,
                itemBuilder: (context, index) {
                  return ItemListTile(
                    item: state.items[index],
                    showTodayCount: state.showTodayCount,
                    onTap: () {
                      context.push('/item-detail/${state.items[index].id}');
                    },
                    onEdit: () {
                      context.push('/item-update/${state.items[index].id}');
                    },
                    onDelete: () {
                      context.read<ItemsBloc>().add(
                            DeleteItem(state.items[index].id),
                          );
                    },
                  );
                },
              );
            }

            return const SizedBox.shrink();
          },
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: () {
            context.push('/item-setup');
          },
          child: const Icon(Icons.add),
        ),
      ),
    );
  }
}
```

**ItemSetupPage** (presentation/pages/item_setup_page.dart):
```dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import '../../../../core/di/injection.dart';
import '../../../../core/utils/validators.dart';
import '../../domain/entities/item.dart';
import '../bloc/items_bloc.dart';

class ItemSetupPage extends StatefulWidget {
  const ItemSetupPage({Key? key}) : super(key: key);

  @override
  State<ItemSetupPage> createState() => _ItemSetupPageState();
}

class _ItemSetupPageState extends State<ItemSetupPage> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  int _incrementBy = 1;
  ReminderType _reminder = ReminderType.none;
  int _reminderValue = 0;

  @override
  void dispose() {
    _nameController.dispose();
    super.dispose();
  }

  void _saveItem() {
    if (_formKey.currentState!.validate()) {
      final newItem = Item(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        name: _nameController.text.trim(),
        count: 0,
        todayCount: 0,
        incrementBy: _incrementBy,
        reminder: _reminder,
        reminderValue: _reminderValue,
        lastResetTime: DateTime.now(),
        lastUpdated: DateTime.now(),
        userId: '', // Will be set by repository
      );

      context.read<ItemsBloc>().add(CreateItem(newItem));
      context.pop();
    }
  }

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (_) => sl<ItemsBloc>(),
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Create Item'),
        ),
        body: Form(
          key: _formKey,
          child: ListView(
            padding: const EdgeInsets.all(16),
            children: [
              TextFormField(
                controller: _nameController,
                decoration: const InputDecoration(
                  labelText: 'Item Name',
                  hintText: 'e.g., Coffee, Exercise, Reading',
                  border: OutlineInputBorder(),
                ),
                validator: Validators.validateItemName,
                maxLength: 30,
              ),
              const SizedBox(height: 16),
              DropdownButtonFormField<int>(
                value: _incrementBy,
                decoration: const InputDecoration(
                  labelText: 'Increment By',
                  border: OutlineInputBorder(),
                ),
                items: List.generate(10, (i) => i + 1)
                    .map((value) => DropdownMenuItem(
                          value: value,
                          child: Text(value.toString()),
                        ))
                    .toList(),
                onChanged: (value) {
                  setState(() {
                    _incrementBy = value!;
                  });
                },
              ),
              const SizedBox(height: 16),
              DropdownButtonFormField<ReminderType>(
                value: _reminder,
                decoration: const InputDecoration(
                  labelText: 'Reminder Type',
                  border: OutlineInputBorder(),
                ),
                items: const [
                  DropdownMenuItem(
                    value: ReminderType.none,
                    child: Text('None'),
                  ),
                  DropdownMenuItem(
                    value: ReminderType.target,
                    child: Text('Target'),
                  ),
                  DropdownMenuItem(
                    value: ReminderType.interval,
                    child: Text('Interval'),
                  ),
                  DropdownMenuItem(
                    value: ReminderType.everyTime,
                    child: Text('Every Time'),
                  ),
                ],
                onChanged: (value) {
                  setState(() {
                    _reminder = value!;
                  });
                },
              ),
              if (_reminder != ReminderType.none) ...[
                const SizedBox(height: 16),
                TextFormField(
                  decoration: const InputDecoration(
                    labelText: 'Reminder Value',
                    border: OutlineInputBorder(),
                  ),
                  keyboardType: TextInputType.number,
                  initialValue: _reminderValue.toString(),
                  validator: (value) =>
                      Validators.validateReminderValue(int.tryParse(value ?? '0')),
                  onChanged: (value) {
                    _reminderValue = int.tryParse(value) ?? 0;
                  },
                ),
              ],
              const SizedBox(height: 24),
              ElevatedButton(
                onPressed: _saveItem,
                child: const Text('Create Item'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

**ItemListTile Widget** (presentation/widgets/item_list_tile.dart):
```dart
import 'package:flutter/material.dart';
import 'package:flutter_slidable/flutter_slidable.dart';
import '../../domain/entities/item.dart';

class ItemListTile extends StatelessWidget {
  final Item item;
  final bool showTodayCount;
  final VoidCallback onTap;
  final VoidCallback onEdit;
  final VoidCallback onDelete;

  const ItemListTile({
    Key? key,
    required this.item,
    required this.showTodayCount,
    required this.onTap,
    required this.onEdit,
    required this.onDelete,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final displayCount = showTodayCount ? item.todayCount : item.count;

    return Slidable(
      endActionPane: ActionPane(
        motion: const ScrollMotion(),
        children: [
          SlidableAction(
            onPressed: (_) => onEdit(),
            backgroundColor: Colors.blue,
            foregroundColor: Colors.white,
            icon: Icons.edit,
            label: 'Edit',
          ),
          SlidableAction(
            onPressed: (_) => onDelete(),
            backgroundColor: Colors.red,
            foregroundColor: Colors.white,
            icon: Icons.delete,
            label: 'Delete',
          ),
        ],
      ),
      child: ListTile(
        onTap: onTap,
        leading: CircleAvatar(
          child: Text(item.name[0].toUpperCase()),
        ),
        title: Text(item.name),
        subtitle: Text(
          'Increment: ${item.incrementBy} â€¢ ${_reminderText()}',
        ),
        trailing: Text(
          displayCount.toString(),
          style: Theme.of(context).textTheme.headlineSmall,
        ),
      ),
    );
  }

  String _reminderText() {
    switch (item.reminder) {
      case ReminderType.target:
        return 'Target: ${item.reminderValue}';
      case ReminderType.interval:
        return 'Interval: ${item.reminderValue}';
      case ReminderType.everyTime:
        return 'Every Time';
      default:
        return 'No reminder';
    }
  }
}
```

## Dependencies

- Task 009: ItemsBloc must be implemented
- flutter_slidable package for swipe actions
- GoRouter for navigation

## Testing

Write widget tests in `test/features/items/presentation/`:

**ItemsPage Tests**:
```dart
testWidgets('displays loading indicator when state is ItemsLoading', (tester) async {
  when(() => mockBloc.state).thenReturn(ItemsLoading());

  await tester.pumpWidget(MaterialApp(home: ItemsPage()));

  expect(find.byType(CircularProgressIndicator), findsOneWidget);
});

testWidgets('displays items list when state is ItemsLoaded', (tester) async {
  when(() => mockBloc.state).thenReturn(ItemsLoaded([testItem]));

  await tester.pumpWidget(MaterialApp(home: ItemsPage()));

  expect(find.byType(ItemListTile), findsOneWidget);
  expect(find.text('Coffee'), findsOneWidget);
});

testWidgets('displays empty state when items list is empty', (tester) async {
  when(() => mockBloc.state).thenReturn(ItemsLoaded([]));

  await tester.pumpWidget(MaterialApp(home: ItemsPage()));

  expect(find.text('No items yet'), findsOneWidget);
});
```

**Form Validation Tests**:
- Test empty name shows validation error
- Test name > 30 chars shows error
- Test valid form submits successfully

## Notes

- Use flutter_slidable for swipe-to-delete/edit
- Form validation uses validators from core/utils
- BlocConsumer shows errors via SnackBar
- Empty state guides user to create first item
- ItemUpdatePage similar to ItemSetupPage but pre-filled

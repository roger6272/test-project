---
epic: flutterflow-to-clean-architecture-migration
status: backlog
priority: P0
estimate: 6-7 hours
depends_on: [008]
week: 2
---

# Task 009: Implement Items BLoC

## Description

Create the presentation layer BLoC (Business Logic Component) for Items feature. This includes events, states, and bloc logic to manage item CRUD operations and state management.

## Acceptance Criteria

- [ ] ItemsEvent classes created in `features/items/presentation/bloc/items_event.dart`
- [ ] ItemsState classes created in `features/items/presentation/bloc/items_state.dart`
- [ ] ItemsBloc created in `features/items/presentation/bloc/items_bloc.dart`
- [ ] All 6 events handled: LoadItems, CreateItem, UpdateItem, DeleteItem, ActivateItem, ToggleCountView
- [ ] All 4 states defined: ItemsInitial, ItemsLoading, ItemsLoaded, ItemsError
- [ ] BLoC registered in GetIt as factory
- [ ] BLoC logic tested with bloc_test

## Technical Details

**ItemsEvent** (presentation/bloc/items_event.dart):
```dart
import 'package:equatable/equatable.dart';
import '../../domain/entities/item.dart';

abstract class ItemsEvent extends Equatable {
  const ItemsEvent();

  @override
  List<Object?> get props => [];
}

class LoadItems extends ItemsEvent {}

class CreateItem extends ItemsEvent {
  final Item item;

  const CreateItem(this.item);

  @override
  List<Object?> get props => [item];
}

class UpdateItem extends ItemsEvent {
  final Item item;

  const UpdateItem(this.item);

  @override
  List<Object?> get props => [item];
}

class DeleteItem extends ItemsEvent {
  final String itemId;

  const DeleteItem(this.itemId);

  @override
  List<Object?> get props => [itemId];
}

class ActivateItem extends ItemsEvent {
  final String itemId;

  const ActivateItem(this.itemId);

  @override
  List<Object?> get props => [itemId];
}

class ToggleCountView extends ItemsEvent {
  final bool showTodayCount;

  const ToggleCountView(this.showTodayCount);

  @override
  List<Object?> get props => [showTodayCount];
}
```

**ItemsState** (presentation/bloc/items_state.dart):
```dart
import 'package:equatable/equatable.dart';
import '../../domain/entities/item.dart';

abstract class ItemsState extends Equatable {
  const ItemsState();

  @override
  List<Object?> get props => [];
}

class ItemsInitial extends ItemsState {}

class ItemsLoading extends ItemsState {}

class ItemsLoaded extends ItemsState {
  final List<Item> items;
  final bool showTodayCount;

  const ItemsLoaded(this.items, {this.showTodayCount = false});

  @override
  List<Object?> get props => [items, showTodayCount];

  ItemsLoaded copyWith({
    List<Item>? items,
    bool? showTodayCount,
  }) {
    return ItemsLoaded(
      items ?? this.items,
      showTodayCount: showTodayCount ?? this.showTodayCount,
    );
  }
}

class ItemsError extends ItemsState {
  final String message;

  const ItemsError(this.message);

  @override
  List<Object?> get props => [message];
}
```

**ItemsBloc** (presentation/bloc/items_bloc.dart):
```dart
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../core/usecases/usecase.dart';
import '../../domain/usecases/activate_item.dart';
import '../../domain/usecases/create_item.dart';
import '../../domain/usecases/delete_item.dart';
import '../../domain/usecases/get_items.dart';
import '../../domain/usecases/update_item.dart';
import 'items_event.dart';
import 'items_state.dart';

class ItemsBloc extends Bloc<ItemsEvent, ItemsState> {
  final GetItemsUseCase getItems;
  final CreateItemUseCase createItem;
  final UpdateItemUseCase updateItem;
  final DeleteItemUseCase deleteItem;
  final ActivateItemUseCase activateItem;

  ItemsBloc({
    required this.getItems,
    required this.createItem,
    required this.updateItem,
    required this.deleteItem,
    required this.activateItem,
  }) : super(ItemsInitial()) {
    on<LoadItems>(_onLoadItems);
    on<CreateItem>(_onCreateItem);
    on<UpdateItem>(_onUpdateItem);
    on<DeleteItem>(_onDeleteItem);
    on<ActivateItem>(_onActivateItem);
    on<ToggleCountView>(_onToggleCountView);
  }

  Future<void> _onLoadItems(
    LoadItems event,
    Emitter<ItemsState> emit,
  ) async {
    emit(ItemsLoading());

    final result = await getItems(NoParams());

    result.fold(
      (failure) => emit(ItemsError(failure.message)),
      (items) => emit(ItemsLoaded(items)),
    );
  }

  Future<void> _onCreateItem(
    CreateItem event,
    Emitter<ItemsState> emit,
  ) async {
    final currentState = state;

    emit(ItemsLoading());

    final result = await createItem(CreateItemParams(item: event.item));

    result.fold(
      (failure) => emit(ItemsError(failure.message)),
      (_) {
        // Reload items after creation
        add(LoadItems());
      },
    );
  }

  Future<void> _onUpdateItem(
    UpdateItem event,
    Emitter<ItemsState> emit,
  ) async {
    final currentState = state;

    if (currentState is ItemsLoaded) {
      emit(ItemsLoading());

      final result = await updateItem(UpdateItemParams(item: event.item));

      result.fold(
        (failure) => emit(ItemsError(failure.message)),
        (_) {
          // Update items list optimistically
          final updatedItems = currentState.items.map((item) {
            return item.id == event.item.id ? event.item : item;
          }).toList();
          emit(ItemsLoaded(updatedItems, showTodayCount: currentState.showTodayCount));
        },
      );
    }
  }

  Future<void> _onDeleteItem(
    DeleteItem event,
    Emitter<ItemsState> emit,
  ) async {
    final currentState = state;

    if (currentState is ItemsLoaded) {
      emit(ItemsLoading());

      final result = await deleteItem(DeleteItemParams(itemId: event.itemId));

      result.fold(
        (failure) => emit(ItemsError(failure.message)),
        (_) {
          // Remove item from list optimistically
          final updatedItems = currentState.items
              .where((item) => item.id != event.itemId)
              .toList();
          emit(ItemsLoaded(updatedItems, showTodayCount: currentState.showTodayCount));
        },
      );
    }
  }

  Future<void> _onActivateItem(
    ActivateItem event,
    Emitter<ItemsState> emit,
  ) async {
    final currentState = state;

    if (currentState is ItemsLoaded) {
      final result = await activateItem(ActivateItemParams(itemId: event.itemId));

      result.fold(
        (failure) => emit(ItemsError(failure.message)),
        (_) => add(LoadItems()), // Reload to get updated activation state
      );
    }
  }

  Future<void> _onToggleCountView(
    ToggleCountView event,
    Emitter<ItemsState> emit,
  ) async {
    final currentState = state;

    if (currentState is ItemsLoaded) {
      emit(currentState.copyWith(showTodayCount: event.showTodayCount));
    }
  }
}
```

**GetIt Registration** (core/di/injection.dart):
```dart
// Add to init() function
// BLoCs (factories - new instance per use)
sl.registerFactory(() => ItemsBloc(
      getItems: sl(),
      createItem: sl(),
      updateItem: sl(),
      deleteItem: sl(),
      activateItem: sl(),
    ));
```

## Dependencies

- Task 008: Items data layer must be complete
- All use cases from Task 007 must be implemented

## Testing

Write BLoC tests in `test/features/items/presentation/bloc/items_bloc_test.dart`:

```dart
import 'package:bloc_test/bloc_test.dart';
import 'package:dartz/dartz.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';

class MockGetItemsUseCase extends Mock implements GetItemsUseCase {}
class MockCreateItemUseCase extends Mock implements CreateItemUseCase {}
class MockUpdateItemUseCase extends Mock implements UpdateItemUseCase {}
class MockDeleteItemUseCase extends Mock implements DeleteItemUseCase {}
class MockActivateItemUseCase extends Mock implements ActivateItemUseCase {}

void main() {
  late ItemsBloc bloc;
  late MockGetItemsUseCase mockGetItems;
  late MockCreateItemUseCase mockCreateItem;
  late MockUpdateItemUseCase mockUpdateItem;
  late MockDeleteItemUseCase mockDeleteItem;
  late MockActivateItemUseCase mockActivateItem;

  final testItem = Item(
    id: 'test_123',
    name: 'Coffee',
    count: 10,
    todayCount: 5,
    incrementBy: 1,
    reminder: ReminderType.target,
    reminderValue: 20,
    lastResetTime: DateTime(2026, 1, 1),
    lastUpdated: DateTime(2026, 1, 2),
    userId: 'user_123',
  );

  setUp(() {
    mockGetItems = MockGetItemsUseCase();
    mockCreateItem = MockCreateItemUseCase();
    mockUpdateItem = MockUpdateItemUseCase();
    mockDeleteItem = MockDeleteItemUseCase();
    mockActivateItem = MockActivateItemUseCase();

    bloc = ItemsBloc(
      getItems: mockGetItems,
      createItem: mockCreateItem,
      updateItem: mockUpdateItem,
      deleteItem: mockDeleteItem,
      activateItem: mockActivateItem,
    );
  });

  group('LoadItems', () {
    blocTest<ItemsBloc, ItemsState>(
      'emits [ItemsLoading, ItemsLoaded] when LoadItems succeeds',
      build: () {
        when(() => mockGetItems(any()))
            .thenAnswer((_) async => Right([testItem]));
        return bloc;
      },
      act: (bloc) => bloc.add(LoadItems()),
      expect: () => [
        ItemsLoading(),
        ItemsLoaded([testItem]),
      ],
    );

    blocTest<ItemsBloc, ItemsState>(
      'emits [ItemsLoading, ItemsError] when LoadItems fails',
      build: () {
        when(() => mockGetItems(any()))
            .thenAnswer((_) async => const Left(ServerFailure('Failed to load items')));
        return bloc;
      },
      act: (bloc) => bloc.add(LoadItems()),
      expect: () => [
        ItemsLoading(),
        const ItemsError('Failed to load items'),
      ],
    );
  });

  group('CreateItem', () {
    blocTest<ItemsBloc, ItemsState>(
      'emits loading and reloads items when CreateItem succeeds',
      build: () {
        when(() => mockCreateItem(any()))
            .thenAnswer((_) async => const Right(null));
        when(() => mockGetItems(any()))
            .thenAnswer((_) async => Right([testItem]));
        return bloc;
      },
      act: (bloc) => bloc.add(CreateItem(testItem)),
      expect: () => [
        ItemsLoading(),
        ItemsLoading(),
        ItemsLoaded([testItem]),
      ],
    );
  });

  group('ToggleCountView', () {
    blocTest<ItemsBloc, ItemsState>(
      'toggles showTodayCount when in ItemsLoaded state',
      build: () => bloc,
      seed: () => ItemsLoaded([testItem], showTodayCount: false),
      act: (bloc) => bloc.add(const ToggleCountView(true)),
      expect: () => [
        ItemsLoaded([testItem], showTodayCount: true),
      ],
    );
  });
}
```

Test coverage requirements:
- [ ] All 6 event handlers tested
- [ ] Success and failure paths for each event
- [ ] State transitions verified
- [ ] Use case calls verified with mocktail
- [ ] Edge cases (empty lists, null states)

## Notes

- Use BlocProvider in widgets to access ItemsBloc
- BLoC handles all business logic - UI only dispatches events
- Optimistic updates for better UX (update/delete)
- Error states should be shown to user with SnackBar
- Loading states enable progress indicators
- ToggleCountView toggles between count and todayCount display

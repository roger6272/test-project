---
epic: flutterflow-to-clean-architecture-migration
status: backlog
priority: P0
estimate: 4-5 hours
depends_on: [008, 009]
week: 3
---

# Task 011: Write Unit Tests for Items Feature

## Description

Create comprehensive unit tests for Items feature covering domain layer (use cases), data layer (repository, data source), and presentation layer (BLoC). Achieve 70%+ test coverage for business logic.

## Acceptance Criteria

- [ ] All 5 use cases have unit tests (GetItems, CreateItem, UpdateItem, DeleteItem, ActivateItem)
- [ ] ItemModel serialization tests written
- [ ] ItemFirestoreDataSource tests written with mocked Firestore
- [ ] ItemRepositoryImpl tests written with mocked data source
- [ ] ItemsBloc tests written with bloc_test
- [ ] Test coverage â‰¥ 70% for Items feature
- [ ] All tests passing in CI/CD pipeline

## Technical Details

**Use Case Tests** (test/features/items/domain/usecases/):

```dart
// get_items_test.dart
void main() {
  late GetItemsUseCase useCase;
  late MockItemRepository mockRepository;

  setUp(() {
    mockRepository = MockItemRepository();
    useCase = GetItemsUseCase(mockRepository);
  });

  final testItems = [
    testItem1,
    testItem2,
  ];

  test('should get items from repository', () async {
    // arrange
    when(() => mockRepository.getItems())
        .thenAnswer((_) async => Right(testItems));

    // act
    final result = await useCase(NoParams());

    // assert
    expect(result, Right(testItems));
    verify(() => mockRepository.getItems()).called(1);
    verifyNoMoreInteractions(mockRepository);
  });

  test('should return failure when repository fails', () async {
    // arrange
    when(() => mockRepository.getItems())
        .thenAnswer((_) async => const Left(ServerFailure('Error')));

    // act
    final result = await useCase(NoParams());

    // assert
    expect(result, const Left(ServerFailure('Error')));
  });
}
```

**Model Tests** (test/features/items/data/models/item_model_test.dart):

```dart
void main() {
  final testItemModel = ItemModel(/* ... */);

  group('ItemModel', () {
    test('should be a subclass of Item entity', () {
      expect(testItemModel, isA<Item>());
    });

    test('toFirestore should return valid map', () {
      final result = testItemModel.toFirestore();

      expect(result['item_name'], 'Coffee');
      expect(result['count'], 10);
      expect(result['todaycount'], 5);
      expect(result['increment_by'], 1);
      expect(result['reminder'], 'TARGET');
      expect(result['reminder_value'], 20);
      expect(result['user_id'], 'user_123');
    });

    test('fromFirestore should create model from map', () {
      final map = {
        'item_name': 'Coffee',
        'count': 10,
        'todaycount': 5,
        'increment_by': 1,
        'reminder': 'TARGET',
        'reminder_value': 20,
        'lastResetTime': 1704067200000,
        'lastUpdated': 1704153600000,
        'user_id': 'user_123',
      };

      final mockDoc = MockDocumentSnapshot();
      when(() => mockDoc.id).thenReturn('test_123');
      when(() => mockDoc.data()).thenReturn(map);

      final result = ItemModel.fromFirestore(mockDoc);

      expect(result.id, 'test_123');
      expect(result.name, 'Coffee');
      expect(result.count, 10);
      expect(result.reminder, ReminderType.target);
    });

    test('should handle missing fields with defaults', () {
      final map = {
        'item_name': 'Coffee',
        'user_id': 'user_123',
      };

      final mockDoc = MockDocumentSnapshot();
      when(() => mockDoc.id).thenReturn('test_123');
      when(() => mockDoc.data()).thenReturn(map);

      final result = ItemModel.fromFirestore(mockDoc);

      expect(result.count, 0);
      expect(result.todayCount, 0);
      expect(result.incrementBy, 1);
      expect(result.reminderValue, 0);
    });
  });
}
```

**DataSource Tests** (test/features/items/data/datasources/item_firestore_datasource_test.dart):

```dart
void main() {
  late ItemFirestoreDataSourceImpl dataSource;
  late MockFirebaseFirestore mockFirestore;
  late MockCollectionReference mockCollection;
  late MockQuerySnapshot mockQuerySnapshot;

  setUp(() {
    mockFirestore = MockFirebaseFirestore();
    mockCollection = MockCollectionReference();
    mockQuerySnapshot = MockQuerySnapshot();
    dataSource = ItemFirestoreDataSourceImpl(mockFirestore);
  });

  group('getItems', () {
    test('should return list of ItemModels on success', () async {
      // arrange
      when(() => mockFirestore.collection('Item'))
          .thenReturn(mockCollection);
      when(() => mockCollection.where('user_id', isEqualTo: 'user_123'))
          .thenReturn(mockQuery);
      when(() => mockQuery.get())
          .thenAnswer((_) async => mockQuerySnapshot);
      when(() => mockQuerySnapshot.docs)
          .thenReturn([mockDocSnapshot]);

      // act
      final result = await dataSource.getItems('user_123');

      // assert
      expect(result, isA<List<ItemModel>>());
    });

    test('should throw ServerException when Firestore fails', () async {
      // arrange
      when(() => mockFirestore.collection('Item'))
          .thenThrow(Exception('Firestore error'));

      // act & assert
      expect(
        () => dataSource.getItems('user_123'),
        throwsA(isA<ServerException>()),
      );
    });
  });

  group('createItem', () {
    test('should call Firestore set with correct data', () async {
      // arrange
      final testItem = testItemModel;
      when(() => mockFirestore.collection('Item'))
          .thenReturn(mockCollection);
      when(() => mockCollection.doc(testItem.id))
          .thenReturn(mockDocReference);
      when(() => mockDocReference.set(any()))
          .thenAnswer((_) async => {});

      // act
      await dataSource.createItem(testItem);

      // assert
      verify(() => mockDocReference.set(testItem.toFirestore())).called(1);
    });
  });
}
```

**Repository Tests** (test/features/items/data/repositories/item_repository_impl_test.dart):

```dart
void main() {
  late ItemRepositoryImpl repository;
  late MockItemFirestoreDataSource mockDataSource;
  late MockFirebaseAuth mockAuth;
  late MockUser mockUser;

  setUp(() {
    mockDataSource = MockItemFirestoreDataSource();
    mockAuth = MockFirebaseAuth();
    mockUser = MockUser();
    repository = ItemRepositoryImpl(mockDataSource, mockAuth);

    when(() => mockAuth.currentUser).thenReturn(mockUser);
    when(() => mockUser.uid).thenReturn('user_123');
  });

  group('getItems', () {
    test('should return items when data source succeeds', () async {
      // arrange
      when(() => mockDataSource.getItems('user_123'))
          .thenAnswer((_) async => [testItemModel]);

      // act
      final result = await repository.getItems();

      // assert
      expect(result, Right([testItemModel]));
      verify(() => mockDataSource.getItems('user_123')).called(1);
    });

    test('should return ServerFailure when data source throws ServerException', () async {
      // arrange
      when(() => mockDataSource.getItems('user_123'))
          .thenThrow(ServerException('Error'));

      // act
      final result = await repository.getItems();

      // assert
      expect(result, const Left(ServerFailure('Error')));
    });
  });
}
```

## Dependencies

- Task 008: Items data layer complete
- Task 009: Items BLoC complete
- Task 005: Testing infrastructure set up

## Testing

Run tests and verify coverage:

```bash
# Run all tests
flutter test test/features/items/

# Run with coverage
flutter test --coverage test/features/items/

# Generate coverage report
genhtml coverage/lcov.info -o coverage/html
open coverage/html/index.html
```

Verify coverage metrics:
- [ ] Domain layer: 100% coverage (pure Dart, easy to test)
- [ ] Data layer: 80%+ coverage
- [ ] Presentation layer (BLoC): 80%+ coverage
- [ ] Overall Items feature: 70%+ coverage

## Notes

- Use mocktail for all mocking (null-safe)
- Test both success and failure paths
- Verify interactions with mocks (called(1), verifyNoMoreInteractions)
- Use test fixtures for consistent test data
- Group related tests with group()
- Use descriptive test names following "should ... when ..." pattern
- Mock Firebase classes to avoid real Firestore calls
- BLoC tests use bloc_test for clean state verification

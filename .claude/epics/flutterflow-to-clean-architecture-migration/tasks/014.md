---
epic: flutterflow-to-clean-architecture-migration
status: backlog
priority: P0
estimate: 4-5 hours
depends_on: [013]
week: 3
---

# Task 014: Implement Bluetooth Domain Layer

## Description

Create the domain layer for Bluetooth feature including entities for Bluetooth devices and connection state, repository interface, and use cases for scanning, connecting, and communicating with ESP32 devices.

## Acceptance Criteria

- [ ] BluetoothDevice entity created
- [ ] ConnectionState entity created
- [ ] BluetoothRepository interface created
- [ ] 5 use cases created:
  - [ ] ScanDevicesUseCase (stream)
  - [ ] ConnectDeviceUseCase
  - [ ] DisconnectDeviceUseCase
  - [ ] SendItemListUseCase
  - [ ] WatchConnectionStateUseCase (stream)
- [ ] All use cases extend base UseCase
- [ ] Stream-based use cases properly defined

## Technical Details

**BluetoothDevice Entity** (features/bluetooth/domain/entities/bluetooth_device.dart):
```dart
import 'package:equatable/equatable.dart';

class BluetoothDevice extends Equatable {
  final String id;
  final String name;
  final int rssi;

  const BluetoothDevice({
    required this.id,
    required this.name,
    required this.rssi,
  });

  @override
  List<Object?> get props => [id, name, rssi];
}
```

**ConnectionState Entity** (features/bluetooth/domain/entities/connection_state.dart):
```dart
import 'package:equatable/equatable.dart';
import 'bluetooth_device.dart';

enum ConnectionStatus {
  disconnected,
  connecting,
  connected,
  error,
}

class ConnectionState extends Equatable {
  final ConnectionStatus status;
  final BluetoothDevice? device;
  final String? errorMessage;

  const ConnectionState({
    required this.status,
    this.device,
    this.errorMessage,
  });

  const ConnectionState.disconnected()
      : status = ConnectionStatus.disconnected,
        device = null,
        errorMessage = null;

  const ConnectionState.connecting(BluetoothDevice device)
      : status = ConnectionStatus.connecting,
        device = device,
        errorMessage = null;

  const ConnectionState.connected(BluetoothDevice device)
      : status = ConnectionStatus.connected,
        device = device,
        errorMessage = null;

  const ConnectionState.error(String message)
      : status = ConnectionStatus.error,
        device = null,
        errorMessage = message;

  @override
  List<Object?> get props => [status, device, errorMessage];
}
```

**BluetoothRepository Interface** (features/bluetooth/domain/repositories/bluetooth_repository.dart):
```dart
import 'package:dartz/dartz.dart';
import '../../../../core/error/failures.dart';
import '../../../items/domain/entities/item.dart';
import '../entities/bluetooth_device.dart';
import '../entities/connection_state.dart';

abstract class BluetoothRepository {
  /// Scan for available Bluetooth devices (ESP32)
  Stream<Either<Failure, List<BluetoothDevice>>> scanDevices();

  /// Connect to a Bluetooth device
  Future<Either<Failure, void>> connectDevice(String deviceId);

  /// Disconnect from current device
  Future<Either<Failure, void>> disconnectDevice();

  /// Send item list to ESP32 (chunked, 180-byte MTU)
  Future<Either<Failure, void>> sendItemList(List<Item> items);

  /// Send timezone offset to ESP32
  Future<Either<Failure, void>> sendTimezone(int offsetMinutes);

  /// Watch connection state changes
  Stream<ConnectionState> watchConnectionState();

  /// Listen for events from ESP32
  Stream<Map<String, dynamic>> listenForEvents();
}
```

**ScanDevicesUseCase** (features/bluetooth/domain/usecases/scan_devices.dart):
```dart
import 'package:dartz/dartz.dart';
import '../../../../core/error/failures.dart';
import '../../../../core/usecases/usecase.dart';
import '../entities/bluetooth_device.dart';
import '../repositories/bluetooth_repository.dart';

class ScanDevicesUseCase implements UseCase<Stream<List<BluetoothDevice>>, NoParams> {
  final BluetoothRepository repository;

  ScanDevicesUseCase(this.repository);

  @override
  Future<Either<Failure, Stream<List<BluetoothDevice>>>> call(NoParams params) async {
    // Transform stream to unwrap Either
    final scanStream = repository.scanDevices();

    // Check if first emission is an error
    await for (final result in scanStream) {
      if (result.isLeft()) {
        return result.fold(
          (failure) => Left(failure),
          (_) => throw Exception('Unexpected right value'),
        );
      }

      // Return successful stream
      return Right(scanStream.map((either) => either.fold(
        (failure) => <BluetoothDevice>[],
        (devices) => devices,
      )));
    }

    return const Right(Stream.empty());
  }
}
```

**ConnectDeviceUseCase** (features/bluetooth/domain/usecases/connect_device.dart):
```dart
import 'package:dartz/dartz.dart';
import '../../../../core/error/failures.dart';
import '../../../../core/usecases/usecase.dart';
import '../repositories/bluetooth_repository.dart';

class ConnectDeviceUseCase implements UseCase<void, ConnectDeviceParams> {
  final BluetoothRepository repository;

  ConnectDeviceUseCase(this.repository);

  @override
  Future<Either<Failure, void>> call(ConnectDeviceParams params) async {
    return await repository.connectDevice(params.deviceId);
  }
}

class ConnectDeviceParams {
  final String deviceId;

  ConnectDeviceParams({required this.deviceId});
}
```

**SendItemListUseCase** (features/bluetooth/domain/usecases/send_item_list.dart):
```dart
import 'package:dartz/dartz.dart';
import '../../../../core/error/failures.dart';
import '../../../../core/usecases/usecase.dart';
import '../../../items/domain/entities/item.dart';
import '../repositories/bluetooth_repository.dart';

class SendItemListUseCase implements UseCase<void, SendItemListParams> {
  final BluetoothRepository repository;

  SendItemListUseCase(this.repository);

  @override
  Future<Either<Failure, void>> call(SendItemListParams params) async {
    // Validate items list
    if (params.items.isEmpty) {
      return const Left(ValidationFailure('Items list cannot be empty'));
    }

    if (params.items.length > 50) {
      return const Left(ValidationFailure('Cannot send more than 50 items'));
    }

    return await repository.sendItemList(params.items);
  }
}

class SendItemListParams {
  final List<Item> items;

  SendItemListParams({required this.items});
}
```

**WatchConnectionStateUseCase** (features/bluetooth/domain/usecases/watch_connection_state.dart):
```dart
import 'package:dartz/dartz.dart';
import '../../../../core/error/failures.dart';
import '../../../../core/usecases/usecase.dart';
import '../entities/connection_state.dart';
import '../repositories/bluetooth_repository.dart';

class WatchConnectionStateUseCase implements UseCase<Stream<ConnectionState>, NoParams> {
  final BluetoothRepository repository;

  WatchConnectionStateUseCase(this.repository);

  @override
  Future<Either<Failure, Stream<ConnectionState>>> call(NoParams params) async {
    return Right(repository.watchConnectionState());
  }
}
```

## Dependencies

- Task 003: Base classes created
- Task 013: Items feature deployed (needed for SendItemList)

## Testing

Write unit tests in `test/features/bluetooth/domain/usecases/`:

```dart
// connect_device_test.dart
void main() {
  late ConnectDeviceUseCase useCase;
  late MockBluetoothRepository mockRepository;

  setUp(() {
    mockRepository = MockBluetoothRepository();
    useCase = ConnectDeviceUseCase(mockRepository);
  });

  test('should connect to device via repository', () async {
    // arrange
    when(() => mockRepository.connectDevice('device_123'))
        .thenAnswer((_) async => const Right(null));

    // act
    final result = await useCase(ConnectDeviceParams(deviceId: 'device_123'));

    // assert
    expect(result, const Right(null));
    verify(() => mockRepository.connectDevice('device_123')).called(1);
  });

  test('should return failure when repository fails', () async {
    // arrange
    when(() => mockRepository.connectDevice(any()))
        .thenAnswer((_) async => const Left(BluetoothFailure('Connection failed')));

    // act
    final result = await useCase(ConnectDeviceParams(deviceId: 'device_123'));

    // assert
    expect(result, const Left(BluetoothFailure('Connection failed')));
  });
}
```

## Notes

- Bluetooth operations are asynchronous and may fail
- Use streams for scanning and connection state watching
- ESP32 protocol requires chunking for large payloads
- Connection timeout should be 5 seconds
- Scan timeout should be 15 seconds
- Repository abstraction enables mock Bluetooth service for testing

---
epic: flutterflow-to-clean-architecture-migration
status: backlog
priority: P0
estimate: 6-7 hours
depends_on: [015, 016]
week: 4
---

# Task 017: Implement Bluetooth BLoC

## Description

Create the Bluetooth BLoC for managing Bluetooth state, device scanning, connection, and communication with ESP32. This BLoC orchestrates all Bluetooth operations and maintains connection state.

## Acceptance Criteria

- [ ] BluetoothEvent classes created (StartScan, StopScan, ConnectDevice, DisconnectDevice, SendItemList)
- [ ] BluetoothState classes created (Initial, Scanning, DevicesFound, Connecting, Connected, Disconnected, Error)
- [ ] BluetoothBloc created with all event handlers
- [ ] Stream subscriptions properly managed
- [ ] Connection state watched and emitted
- [ ] Automatic reconnection logic implemented
- [ ] BLoC registered in GetIt

## Technical Details

**BluetoothEvent**:
```dart
abstract class BluetoothEvent extends Equatable {
  const BluetoothEvent();
  @override
  List<Object?> get props => [];
}

class StartScan extends BluetoothEvent {}
class StopScan extends BluetoothEvent {}

class ConnectDevice extends BluetoothEvent {
  final String deviceId;
  const ConnectDevice(this.deviceId);
  @override
  List<Object?> get props => [deviceId];
}

class DisconnectDevice extends BluetoothEvent {}

class SendItemList extends BluetoothEvent {
  final List<Item> items;
  const SendItemList(this.items);
  @override
  List<Object?> get props => [items];
}

class ConnectionStateChanged extends BluetoothEvent {
  final ConnectionState connectionState;
  const ConnectionStateChanged(this.connectionState);
  @override
  List<Object?> get props => [connectionState];
}
```

**BluetoothState**:
```dart
abstract class BluetoothState extends Equatable {
  const BluetoothState();
  @override
  List<Object?> get props => [];
}

class BluetoothInitial extends BluetoothState {}

class BluetoothScanning extends BluetoothState {}

class BluetoothDevicesFound extends BluetoothState {
  final List<BluetoothDevice> devices;
  const BluetoothDevicesFound(this.devices);
  @override
  List<Object?> get props => [devices];
}

class BluetoothConnecting extends BluetoothState {
  final BluetoothDevice device;
  const BluetoothConnecting(this.device);
  @override
  List<Object?> get props => [device];
}

class BluetoothConnected extends BluetoothState {
  final BluetoothDevice device;
  const BluetoothConnected(this.device);
  @override
  List<Object?> get props => [device];
}

class BluetoothDisconnected extends BluetoothState {}

class BluetoothError extends BluetoothState {
  final String message;
  const BluetoothError(this.message);
  @override
  List<Object?> get props => [message];
}
```

**BluetoothBloc**:
```dart
class BluetoothBloc extends Bloc<BluetoothEvent, BluetoothState> {
  final ScanDevicesUseCase scanDevices;
  final ConnectDeviceUseCase connectDevice;
  final DisconnectDeviceUseCase disconnectDevice;
  final SendItemListUseCase sendItemList;
  final WatchConnectionStateUseCase watchConnectionState;

  StreamSubscription? _scanSubscription;
  StreamSubscription? _connectionSubscription;

  BluetoothBloc({
    required this.scanDevices,
    required this.connectDevice,
    required this.disconnectDevice,
    required this.sendItemList,
    required this.watchConnectionState,
  }) : super(BluetoothInitial()) {
    on<StartScan>(_onStartScan);
    on<StopScan>(_onStopScan);
    on<ConnectDevice>(_onConnectDevice);
    on<DisconnectDevice>(_onDisconnectDevice);
    on<SendItemList>(_onSendItemList);
    on<ConnectionStateChanged>(_onConnectionStateChanged);
  }

  Future<void> _onStartScan(StartScan event, Emitter<BluetoothState> emit) async {
    emit(BluetoothScanning());

    final result = await scanDevices(NoParams());

    result.fold(
      (failure) => emit(BluetoothError(failure.message)),
      (deviceStream) {
        _scanSubscription = deviceStream.listen(
          (devices) => emit(BluetoothDevicesFound(devices)),
          onError: (error) => emit(BluetoothError(error.toString())),
        );
      },
    );
  }

  Future<void> _onConnectDevice(ConnectDevice event, Emitter<BluetoothState> emit) async {
    final currentState = state;
    if (currentState is BluetoothDevicesFound) {
      final device = currentState.devices.firstWhere((d) => d.id == event.deviceId);
      emit(BluetoothConnecting(device));

      final result = await connectDevice(ConnectDeviceParams(deviceId: event.deviceId));

      result.fold(
        (failure) => emit(BluetoothError(failure.message)),
        (_) => emit(BluetoothConnected(device)),
      );
    }
  }

  @override
  Future<void> close() {
    _scanSubscription?.cancel();
    _connectionSubscription?.cancel();
    return super.close();
  }
}
```

## Dependencies

- Task 015: Bluetooth data layer
- All Bluetooth use cases from Task 014

## Testing

BLoC tests with bloc_test:
- Test scanning emits devices
- Test connection success/failure
- Test disconnection
- Test error states
- Test stream subscription management

## Notes

- Dispose stream subscriptions in close()
- Watch connection state for auto-reconnect
- Emit errors to UI via states

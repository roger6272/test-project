---
epic: flutterflow-to-clean-architecture-migration
status: backlog
priority: P1
estimate: 4-5 hours
depends_on: [025]
week: 5-6
---

# Task 026: Implement CSV Export Domain Layer and Generation Logic

## Description

Create domain layer and CSV generation logic for data export feature. Implement use cases for generating CSV files from event data with configurable aggregation levels.

## Acceptance Criteria

- [ ] GenerateCSVUseCase created
- [ ] CSV generation logic implemented
- [ ] Aggregation levels supported (raw, daily, weekly, monthly)
- [ ] CSV format matches specification (Item Name, Date, Event Count)
- [ ] Filename generation logic implemented
- [ ] CSV encoding handles special characters

## Technical Details

**GenerateCSVUseCase**:
```dart
class GenerateCSVUseCase implements UseCase<String, GenerateCSVParams> {
  final EventLogRepository repository;

  GenerateCSVUseCase(this.repository);

  @override
  Future<Either<Failure, String>> call(GenerateCSVParams params) async {
    final eventsResult = await repository.getEventsByDateRange(
      params.startDate,
      params.endDate,
    );

    return eventsResult.fold(
      (failure) => Left(failure),
      (events) {
        final csv = _generateCSV(events, params.aggregationLevel);
        return Right(csv);
      },
    );
  }

  String _generateCSV(List<EventLog> events, String aggregationLevel) {
    final buffer = StringBuffer();

    // Header
    buffer.writeln('Item Name,Date,Event Count');

    if (aggregationLevel == 'raw') {
      // Raw events
      for (var event in events) {
        buffer.writeln('${event.eventName},${_formatDate(event.createdTime)},${event.increment}');
      }
    } else {
      // Aggregated events
      final aggregated = _aggregateEvents(events, aggregationLevel);
      for (var entry in aggregated.entries) {
        buffer.writeln('${entry.key.itemName},${_formatDate(entry.key.date)},${entry.value}');
      }
    }

    return buffer.toString();
  }

  Map<AggregationKey, int> _aggregateEvents(List<EventLog> events, String level) {
    final Map<AggregationKey, int> aggregated = {};

    for (var event in events) {
      final key = AggregationKey(
        itemName: event.eventName,
        date: _getAggregationDate(event.createdTime, level),
      );
      aggregated[key] = (aggregated[key] ?? 0) + event.increment;
    }

    return aggregated;
  }

  DateTime _getAggregationDate(DateTime date, String level) {
    switch (level) {
      case 'daily':
        return DateTime(date.year, date.month, date.day);
      case 'weekly':
        final weekday = date.weekday;
        return DateTime(date.year, date.month, date.day - (weekday - 1));
      case 'monthly':
        return DateTime(date.year, date.month);
      default:
        return date;
    }
  }

  String _formatDate(DateTime date) {
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }
}

class AggregationKey {
  final String itemName;
  final DateTime date;

  AggregationKey({required this.itemName, required this.date});

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AggregationKey && itemName == other.itemName && date == other.date;

  @override
  int get hashCode => itemName.hashCode ^ date.hashCode;
}

class GenerateCSVParams {
  final DateTime startDate;
  final DateTime endDate;
  final String aggregationLevel;

  GenerateCSVParams({
    required this.startDate,
    required this.endDate,
    required this.aggregationLevel,
  });
}
```

**Filename Generation**:
```dart
String generateFilename(DateTime startDate, DateTime endDate, String aggregation) {
  final start = '${startDate.year}-${startDate.month}-${startDate.day}';
  final end = '${endDate.year}-${endDate.month}-${endDate.day}';
  return 'tally_export_${start}_to_${end}_$aggregation.csv';
}
```

## Dependencies

- Task 025: EventLog feature complete

## Testing

Unit tests:
- Test CSV generation with raw data
- Test daily aggregation
- Test weekly aggregation
- Test monthly aggregation
- Test CSV formatting
- Test special characters in item names
- Test empty data

## Notes

- CSV must be UTF-8 encoded
- Handle commas in item names with quotes
- Filename must be valid for email attachments
- Test with large datasets (1000+ events)
